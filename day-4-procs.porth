include "helpers.porth"

const BOARD_SIZE 5 5 * end
const BOARD_CELL_SIZE sizeof(int) sizeof(bool) + end
memory numbers sizeof(int) 100 * end // input has 100 in it
memory len(numbers) sizeof(int) end
memory boards BOARD_SIZE BOARD_CELL_SIZE * 100 * end // input has 100 boards in it
memory len(boards) sizeof(int) end
memory p sizeof(ptr) end
memory bingos sizeof(bool) 100 * end // input has 100 boards in it
memory result sizeof(int) end // Save scores to this, the last one will be the one there at the end
boards p !ptr

proc @numbers[i] int -- int in
  numbers @a[i]
end

proc add_number int in
  len(numbers) @64 numbers !a[i]
  len(numbers) inc64
end

proc read_numbers in
  while newline? lnot do
    parse_int_from_buffer add_number
  end
end

proc dump_numbers in
  "numbers: " puts
  0 while dup len(numbers) @64 < do
    dup sizeof(int) * numbers +ptr @64 putu
    " " puts
    1 +
  end drop
  "\n" puts
end

proc read_board -- bool in
  refill_buffer_if_empty
  skip_whitespace_from_buffer
  eof? lnot if
    0 while dup BOARD_SIZE < do
      parse_int_from_buffer
      p @ptr !64
      BOARD_CELL_SIZE p @ptr +ptr p !ptr
      1 +
    end drop
    len(boards) inc64
    true
  else
    false
  end
end

proc dump_board int in // board_id
  "dumping board id " puts dup print
  BOARD_SIZE BOARD_CELL_SIZE * * boards +ptr
  // base_p
  0 while dup BOARD_SIZE < do
    // base_p idx
    2dup BOARD_CELL_SIZE * swap +ptr
    // base_p idx cell_p
    dup @64
    swap sizeof(int) swap +ptr @bool if
      "(" puts putu ")" puts
    else
      " " puts putu " " puts
    end
    1 +
    dup 5 % 0 = if
      "\n" puts
    else
      " " puts
    end
  end drop drop
end

proc has_row ptr -- bool in
  // cell_p
  dup sizeof(int) swap +ptr @bool
  over BOARD_CELL_SIZE 1 * sizeof(int) + swap +ptr @bool land
  over BOARD_CELL_SIZE 2 * sizeof(int) + swap +ptr @bool land
  over BOARD_CELL_SIZE 3 * sizeof(int) + swap +ptr @bool land
  over BOARD_CELL_SIZE 4 * sizeof(int) + swap +ptr @bool land
  swap drop
end

proc has_col ptr -- bool in
  // cell_p
  dup sizeof(int) swap +ptr @bool
  over BOARD_CELL_SIZE 5 * 1 * sizeof(int) + swap +ptr @bool land
  over BOARD_CELL_SIZE 5 * 2 * sizeof(int) + swap +ptr @bool land
  over BOARD_CELL_SIZE 5 * 3 * sizeof(int) + swap +ptr @bool land
  over BOARD_CELL_SIZE 5 * 4 * sizeof(int) + swap +ptr @bool land
  swap drop
end

proc is_bingo int -- bool in // stk: board_idx -> bingo
  false swap // stk: ret board_idx
  BOARD_SIZE BOARD_CELL_SIZE * * boards +ptr // stk: ret cell_p
  0 while dup 5 < do // Loop over both rows and cols, stk: ret cell_p idx
    2dup BOARD_CELL_SIZE 5 * * swap +ptr has_row if // This row is a bingo
      drop drop drop true 0 cast(ptr) 5 // return true (should break loop)
    else 2dup BOARD_CELL_SIZE * swap +ptr has_col if* // This col is a bingo
      drop drop drop true 0 cast(ptr) 5 // return true (should break loop)
    end // stk: ret cell_p idx
    1 +
  end drop drop // stk:
end

proc get_score int -- int in // stk: board_id -> score
  0 swap // stk: score board_id
  BOARD_SIZE BOARD_CELL_SIZE * * boards +ptr // stk: score board_base_p
  dup while over BOARD_SIZE BOARD_CELL_SIZE * swap +ptr over swap ptr< do // For each cell in this board, stk: score base_p cell_p
    sizeof(int) over +ptr @bool lnot if // This cell hasn't been called
      rot over @64 + rot rot // Increment score
    end
    BOARD_CELL_SIZE swap +ptr // Increment to next cell, stk: base_p cell_p
  end drop drop // stk:
end

