include "std.porth"

const STDIN_BUFFER_MAX 10240 end
memory stdin_buffer STDIN_BUFFER_MAX end
memory len(stdin_buffer) sizeof(int) end
memory stdin_buffer_idx sizeof(int) end

// use try-parse-int from std.porth instead
// proc parse_int
//     int ptr int // len buf idx
//     --
//     int int // idx ret
// in
//   memory ret sizeof(int) end
//   memory _tmp sizeof(int) end
//   memory _fin sizeof(bool) end
//   0 ret !64
//   false _fin !bool
// 
//   // len buf idx
//   _tmp !64 swap _tmp @64
//   // buf len idx
//   while 2dup > _fin @bool lnot land do
//     // buf len idx
//     swap _tmp !64 2dup
//     // buf idx buf idx
//     swap +ptr @8
//     // buf idx dig
//     dup isdigit lnot if drop // not a digit
//       // buf idx
//       true _fin !bool
//       // buf idx
//     else // is a digit, add digit to stored int
//       // buf idx dig
//       '0' - ret @64 10 * + ret !64
//       // buf idx
//     end
// 
//     _tmp @64 swap
//     1 +
//     // buf len idx
//   end
//   // buf len idx
//   swap drop swap drop ret @64
//   // idx ret
// end

proc refill_buffer_if_empty in
  len(stdin_buffer) @64 stdin_buffer_idx @64 -
  dup 0 = if
    0 stdin_buffer_idx !64 0 len(stdin_buffer) !64
  end
  dup 100 < if // only refill if not much left
    // len_of_existing
    dup stdin_buffer_idx @64 stdin_buffer +ptr stdin_buffer memcpy drop // size, src, dest -> dest
    0 stdin_buffer_idx !64
    dup len(stdin_buffer) !64
    // len_of_existing
    dup STDIN_BUFFER_MAX swap -
    // len_of_existing len_to_read
    over stdin_buffer +ptr
    // len_of_existing len_to_read buffer_to_read
    stdin read len(stdin_buffer) @64 + len(stdin_buffer) !64
  end drop
end

proc next_char -- int in
  refill_buffer_if_empty
  stdin_buffer_idx @64 stdin_buffer +ptr @8
  stdin_buffer_idx inc64
end

proc eof? -- bool in
  refill_buffer_if_empty
  len(stdin_buffer) @64 stdin_buffer_idx @64 -
  0 =
end

proc newline? -- bool in
  next_char '\n' =
  stdin_buffer_idx dec64
end

proc skip_nondigit_from_buffer -- in
  while eof? lnot next_char isdigit lnot land do
  end stdin_buffer_idx dec64
end

proc skip_whitespace_from_buffer -- in
  while eof? lnot next_char
      dup ' ' =
      over '\t' = lor
      over '\n' = lor
    swap drop land do
  end stdin_buffer_idx dec64
end

proc parse_int_from_buffer -- int in
  skip_nondigit_from_buffer
  refill_buffer_if_empty
  skip_nondigit_from_buffer
  len(stdin_buffer) @64 stdin_buffer_idx @64 - stdin_buffer_idx @64 stdin_buffer +ptr
  try-parse-int
  drop // ignore true/false, it will still parse the start
  while eof? lnot next_char isdigit land do
  end stdin_buffer_idx dec64
end

proc a[i] int ptr -- ptr in
  swap sizeof(int) * swap +ptr
end

proc !a[i] int int ptr in
  a[i] !64
end

proc @a[i] int ptr -- int in
  a[i] @64
end

proc a[i]++ int ptr in
  a[i] dup @64 1 + swap !64
end

proc min_max int int -- int int in
  2dup
  max swap
  // a max b
  2dup = if
    drop
    // a max  --  (b=max)
  else
    swap rot drop
    // b max  --  (b!=max)
  end
end

proc abs int -- int in
  dup 0 < if -1 * end
end
